<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Projector Trace Tool</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #171e34;
      --panel-soft: #202846;
      --accent: #5fb1ff;
      --accent-soft: rgba(95, 177, 255, 0.12);
      --text: #f5f7ff;
      --muted: #a9b2d9;
      --border: #2a345d;
      --danger: #f97373;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: radial-gradient(circle at top, #1a2450 0, #050713 60%);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.9rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(to right, rgba(10,14,34,0.96), rgba(12,24,60,0.96));
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.25rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    header p {
      margin: 0;
      font-size: 0.8rem;
      color: var(--muted);
    }

    main {
      flex: 1;
      display: flex;
      gap: 1rem;
      padding: 1rem;
    }

    .sidebar {
      width: 310px;
      max-width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .panel {
      background: linear-gradient(145deg, var(--panel), #141a30);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.75rem 0.9rem;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35);
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .step-label {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .panel-title {
      font-size: 0.95rem;
      font-weight: 600;
    }

    .chip {
      border-radius: 999px;
      padding: 0.2rem 0.6rem;
      font-size: 0.7rem;
      border: 1px solid rgba(95, 177, 255, 0.6);
      background: rgba(95, 177, 255, 0.08);
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    .field-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      margin-bottom: 0.5rem;
    }

    label {
      font-size: 0.8rem;
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.35rem;
    }

    .value-pill {
      font-size: 0.75rem;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      min-width: 3.2rem;
      text-align: right;
      color: var(--text);
    }

    input[type="file"] {
      width: 100%;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .hint {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 0.15rem;
    }

    .trace-mode-select {
      width: 100%;
      margin-top: 0.25rem;
      padding: 0.35rem 0.45rem;
      border-radius: 0.4rem;
      border: 1px solid var(--border);
      background: rgba(7, 12, 30, 0.9);
      color: var(--text);
      font-size: 0.8rem;
    }

    .slider {
      width: 100%;
    }

    .slider input[type="range"] {
      width: 100%;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-top: 0.15rem;
    }

    .toggle-row label {
      margin: 0;
    }

    .toggle-row input {
      transform: scale(1.1);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.35rem;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.45rem 0.9rem;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      background: var(--accent-soft);
      color: var(--text);
    }

    button.primary {
      background: linear-gradient(135deg, var(--accent), #8ed1ff);
      color: #020617;
    }

    button.outline {
      background: transparent;
      border: 1px solid var(--border);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .tip {
      font-size: 0.72rem;
      color: var(--muted);
      margin-top: 0.3rem;
      border-radius: 0.5rem;
      background: rgba(12, 22, 54, 0.9);
      padding: 0.35rem 0.45rem;
    }

    .tip strong {
      color: var(--accent);
    }

    .tooltip-btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.4);
      color: var(--muted);
      width: 18px;
      height: 18px;
      font-size: 0.7rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
    }

    .tooltip-btn span {
      display: none;
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: #020617;
      padding: 0.45rem 0.6rem;
      border-radius: 0.45rem;
      border: 1px solid var(--border);
      font-size: 0.72rem;
      color: var(--muted);
      width: 220px;
      text-align: left;
      z-index: 20;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
    }

    .tooltip-btn:hover span {
      display: block;
    }

    .tooltip-btn span::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 5px;
      border-style: solid;
      border-color: var(--border) transparent transparent transparent;
    }

    .preview-area {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .preview-wrapper {
      flex: 1;
      background: radial-gradient(circle at top, #141a30 0, #050713 65%);
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.7);
    }

    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .preview-header span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .preview-canvas-shell {
      flex: 1;
      border-radius: 0.7rem;
      border: 1px dashed rgba(62, 77, 134, 0.8);
      background: repeating-linear-gradient(
        45deg,
        rgba(13, 20, 50, 0.9),
        rgba(13, 20, 50, 0.9) 10px,
        rgba(9, 15, 34, 0.9) 10px,
        rgba(9, 15, 34, 0.9) 20px
      );
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
    }

    #previewCanvas {
      max-width: 100%;
      max-height: 100%;
      image-rendering: pixelated;
      background: #000;
    }

    .preview-placeholder {
      text-align: center;
      color: var(--muted);
      font-size: 0.8rem;
      padding: 0 1rem;
    }

    .preview-meta {
      font-size: 0.7rem;
      color: var(--muted);
      margin-top: 0.35rem;
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .preview-meta span {
      white-space: nowrap;
    }

    .mini-orig {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: var(--muted);
    }

    #origThumb {
      width: 40px;
      height: 40px;
      border-radius: 0.35rem;
      border: 1px solid var(--border);
      object-fit: cover;
      background: #020617;
    }

    @media (max-width: 900px) {
      main {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        order: 2;
      }
      .preview-area {
        order: 1;
      }
    }

    @media (max-width: 600px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
<header>
  <div>
    <h1>Projector Trace Tool</h1>
    <p>Best results: student in side profile against a light wall.</p>
  </div>
  <p>Steps: Upload → Adjust → Threshold → Project → Trace</p>
</header>

<main>
  <section class="sidebar" aria-label="Controls">
    <!-- STEP 1: Upload -->
    <div class="panel">
      <div class="panel-header">
        <div>
          <div class="step-label">Step 1</div>
          <div class="panel-title">Upload Student Photo</div>
        </div>
        <span class="chip">Start Here</span>
      </div>
      <div class="field-group">
        <label for="fileInput">
          Choose Image
        </label>
        <input id="fileInput" type="file" accept="image/*" />
        <div class="hint">
          Take a side silhouette with the student darker than the wall (light background).
        </div>
      </div>

      <div class="field-group">
        <label for="traceMode">
          Tracing Mode
        </label>
        <select id="traceMode" class="trace-mode-select">
          <option value="shadow">Cast Shadow Pencil Trace (fill + outline)</option>
          <option value="outline">Bold Outline Only (edge trace)</option>
        </select>
        <div class="hint">
          Use <strong>Cast Shadow</strong> for full silhouette. Switch to <strong>Bold Outline</strong> if you want just the contour.
        </div>
      </div>
    </div>

    <!-- STEP 2: Image Adjust -->
    <div class="panel">
      <div class="panel-header">
        <div>
          <div class="step-label">Step 2</div>
          <div class="panel-title">Image Adjust</div>
        </div>
        <button type="button" class="tooltip-btn">
          ?
          <span>
            <strong>Image Adjust</strong> tunes the photo before we snap it to black/white.
            For side silhouettes, you mostly need the outline of the head and shoulders to stand out
            against the light wall.
          </span>
        </button>
      </div>

      <div class="field-group">
        <label for="contrastSlider">
          <span>Contrast</span>
          <span class="value-pill" id="contrastValue">+0%</span>
        </label>
        <div class="slider">
          <input id="contrastSlider" type="range" min="-40" max="80" value="0" />
        </div>
        <div class="hint">Increase until the profile edge is strong against the light wall.</div>
      </div>

      <div class="field-group">
        <label for="blurSlider">
          <span>Shadow Focus (Blur)</span>
          <span class="value-pill" id="blurValue">3.0px</span>
        </label>
        <div class="slider">
          <input id="blurSlider" type="range" min="0" max="10" step="0.5" value="3" />
        </div>
        <div class="hint">Default blur helps smooth hair and tiny bumps into a cleaner silhouette.</div>
      </div>

      <div class="button-row">
        <button id="resetImageAdjust" type="button" class="outline">Reset Image Adjust</button>
      </div>
    </div>

    <!-- STEP 3: Sensitivity -->
    <div class="panel">
      <div class="panel-header">
        <div>
          <div class="step-label">Step 3</div>
          <div class="panel-title">Sensitivity</div>
        </div>
        <button type="button" class="tooltip-btn">
          ?
          <span>
            <strong>Threshold</strong> decides how much of the student becomes solid black.
            For side silhouettes, aim for a clear filled profile without losing the overall shape.
          </span>
        </button>
      </div>

      <div class="field-group">
        <label for="thresholdSlider">
          <span>Threshold</span>
          <span class="value-pill" id="thresholdValue">170</span>
        </label>
        <div class="slider">
          <input id="thresholdSlider" type="range" min="80" max="230" value="170" />
        </div>
        <div class="hint">
          Slide slowly. Higher values = more filled silhouette. Lower values = thinner shapes and more detail.
        </div>
      </div>

      <div class="toggle-row">
        <label for="subjectLighter">
          Subject is Lighter than Background (rare)
        </label>
        <input id="subjectLighter" type="checkbox" />
      </div>
      <div class="hint">
        Most classroom photos have a <strong>light wall and darker student</strong>.
        Leave this <strong>off</strong>. Turn it on only if your student is glowing brighter than the background
        (strong backlight or window).
      </div>

      <div class="button-row">
        <button id="resetSensitivity" type="button" class="outline">Reset Sensitivity</button>
      </div>
    </div>

    <!-- STEP 4: Projector Setup & Crop -->
    <div class="panel">
      <div class="panel-header">
        <div>
          <div class="step-label">Step 4</div>
          <div class="panel-title">Projector Setup & Crop</div>
        </div>
        <button type="button" class="tooltip-btn">
          ?
          <span>
            Use <strong>Flip Horizontal</strong> if your projector is behind the tracing paper
            (rear projection). Hotspot brightens the center slightly to fight dim edges.
            Crop style lets you choose full frame, circle cameo, or square cameo.
          </span>
        </button>
      </div>

      <div class="toggle-row">
        <label for="flipHorizontal">
          Flip Horizontal (Rear View)
        </label>
        <input id="flipHorizontal" type="checkbox" />
      </div>

      <div class="toggle-row">
        <label for="hotspot">
          Projector Hotspot
        </label>
        <input id="hotspot" type="checkbox" />
      </div>

      <div class="field-group">
        <label for="cropShape">
          <span>Crop Style</span>
        </label>
        <select id="cropShape" class="trace-mode-select">
          <option value="none">No Crop (full frame)</option>
          <option value="circle">Circle Cameo</option>
          <option value="square">Square Cameo</option>
        </select>
        <div class="hint">
          Use cameos for framed art pieces; full frame for big wall tracings.
        </div>
      </div>

      <div class="field-group">
        <label for="cropSize">
          <span>Crop Size</span>
          <span class="value-pill" id="cropSizeValue">90%</span>
        </label>
        <div class="slider">
          <input id="cropSize" type="range" min="50" max="100" value="90" />
        </div>
        <div class="hint">
          Smaller % = tighter around the head. Larger % = more shoulders and background in the cameo.
        </div>
      </div>

      <div class="button-row" style="margin-top:0.75rem;">
        <button id="resetAll" type="button" class="outline">Reset All Settings</button>
      </div>
    </div>

    <!-- STEP 5: Export -->
    <div class="panel">
      <div class="panel-header">
        <div>
          <div class="step-label">Step 5</div>
          <div class="panel-title">Export for Tracing</div>
        </div>
        <span class="chip">Final Step</span>
      </div>

      <div class="button-row">
        <button id="downloadPng" type="button" class="primary" disabled>
          ⬇ PNG
        </button>
        <button id="downloadSvg" type="button" class="outline" disabled>
          ⬇ SVG
        </button>
      </div>
      <div class="tip">
        <strong>Teacher tip:</strong> Set your projector to a blank screen, then open this PNG and tap F11 / full screen
        so the silhouette fills the wall or paper.
      </div>
    </div>
  </section>

  <section class="preview-area" aria-label="Preview">
    <div class="preview-wrapper">
      <div class="preview-header">
        <div>
          <span>Live Trace Preview</span>
        </div>
        <div class="mini-orig">
          <img id="origThumb" alt="Original preview" />
          <span>Original</span>
        </div>
      </div>

      <div class="preview-canvas-shell">
        <canvas id="previewCanvas"></canvas>
        <div id="previewPlaceholder" class="preview-placeholder">
          Upload a student side profile on the left to see the trace preview here.
          This is exactly what will appear on the projector and in your PNG/SVG export.
        </div>
      </div>

      <div class="preview-meta" id="previewMeta" style="display:none;">
        <span id="metaSize"></span>
        <span id="metaMode"></span>
        <span id="metaNote">For best tracing: turn off classroom lights and maximize projection size.</span>
      </div>
    </div>
  </section>
</main>

<script>
  (function() {
    const fileInput = document.getElementById('fileInput');
    const traceModeSelect = document.getElementById('traceMode');

    const contrastSlider = document.getElementById('contrastSlider');
    const blurSlider = document.getElementById('blurSlider');
    const thresholdSlider = document.getElementById('thresholdSlider');

    const contrastValue = document.getElementById('contrastValue');
    const blurValue = document.getElementById('blurValue');
    const thresholdValue = document.getElementById('thresholdValue');

    const subjectLighterCheckbox = document.getElementById('subjectLighter');
    const flipHorizontalCheckbox = document.getElementById('flipHorizontal');
    const hotspotCheckbox = document.getElementById('hotspot');
    const cropShapeSelect = document.getElementById('cropShape');
    const cropSizeSlider = document.getElementById('cropSize');
    const cropSizeValue = document.getElementById('cropSizeValue');

    const resetImageAdjustBtn = document.getElementById('resetImageAdjust');
    const resetSensitivityBtn = document.getElementById('resetSensitivity');
    const resetAllBtn = document.getElementById('resetAll');

    const downloadPngBtn = document.getElementById('downloadPng');
    const downloadSvgBtn = document.getElementById('downloadSvg');

    const previewCanvas = document.getElementById('previewCanvas');
    const previewPlaceholder = document.getElementById('previewPlaceholder');
    const previewMeta = document.getElementById('previewMeta');
    const metaSize = document.getElementById('metaSize');
    const metaMode = document.getElementById('metaMode');
    const origThumb = document.getElementById('origThumb');

    const ctxPreview = previewCanvas.getContext('2d');

    let img = new Image();
    let imgLoaded = false;
    let canvasW = 0;
    let canvasH = 0;

    const state = {
      contrast: 0,
      blur: 3,
      threshold: 170,
      subjectLighter: false, // default: student darker than light background
      flipHorizontal: false,
      hotspot: false,
      cropShape: 'none', // 'none' | 'circle' | 'square'
      cropSize: 0.9, // fraction of min dimension
      traceMode: 'shadow'
    };

    function updateCropControlsDisabled() {
      const disabled = state.cropShape === 'none';
      cropSizeSlider.disabled = disabled;
    }

    function updateLabels() {
      const c = state.contrast;
      const sign = c > 0 ? '+' : '';
      contrastValue.textContent = sign + c + '%';
      blurValue.textContent = state.blur.toFixed(1) + 'px';
      thresholdValue.textContent = state.threshold;
      cropSizeValue.textContent = Math.round(state.cropSize * 100) + '%';
      metaMode.textContent =
        'Mode: ' +
        (state.traceMode === 'shadow'
          ? 'Cast Shadow Pencil Trace'
          : 'Bold Outline Only (edge trace)');
      updateCropControlsDisabled();
    }

    function setDefaultsImageAdjust() {
      state.contrast = 0;
      state.blur = 3;
      contrastSlider.value = '0';
      blurSlider.value = '3';
      updateLabels();
    }

    function setDefaultsSensitivity() {
      state.threshold = 170;
      state.subjectLighter = false;
      thresholdSlider.value = '170';
      subjectLighterCheckbox.checked = false;
      updateLabels();
    }

    function setDefaultsProjector() {
      state.flipHorizontal = false;
      state.hotspot = false;
      state.cropShape = 'none';
      state.cropSize = 0.9;
      flipHorizontalCheckbox.checked = false;
      hotspotCheckbox.checked = false;
      cropShapeSelect.value = 'none';
      cropSizeSlider.value = '90';
      updateLabels();
    }

    function resetAll() {
      setDefaultsImageAdjust();
      setDefaultsSensitivity();
      setDefaultsProjector();
      traceModeSelect.value = 'shadow';
      state.traceMode = 'shadow';
      updateLabels();
      if (imgLoaded) {
        processImage();
      }
    }

    function fitCanvasToImage() {
      if (!imgLoaded) return;
      const maxDim = 1200;
      const ratio = img.width / img.height;
      if (img.width > img.height) {
        canvasW = Math.min(maxDim, img.width);
        canvasH = Math.round(canvasW / ratio);
      } else {
        canvasH = Math.min(maxDim, img.height);
        canvasW = Math.round(canvasH * ratio);
      }
      previewCanvas.width = canvasW;
      previewCanvas.height = canvasH;
      metaSize.textContent = 'Canvas: ' + canvasW + ' × ' + canvasH + ' px';
      previewMeta.style.display = 'flex';
    }

    // Smooth binary mask to "round off" hair weirdness
    function smoothBinaryMask(imgData, w, h) {
      const data = imgData.data;
      const src = new Uint8ClampedArray(w * h);

      // Copy grayscale (0 or 255) from the red channel
      for (let i = 0; i < w * h; i++) {
        src[i] = data[i * 4]; // R channel
      }

      const dst = new Uint8ClampedArray(w * h);
      const radius = 1; // 3x3 neighborhood

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          let sum = 0;
          let count = 0;

          for (let ky = -radius; ky <= radius; ky++) {
            const ny = y + ky;
            if (ny < 0 || ny >= h) continue;

            for (let kx = -radius; kx <= radius; kx++) {
              const nx = x + kx;
              if (nx < 0 || nx >= w) continue;

              sum += src[ny * w + nx];
              count++;
            }
          }

          const avg = sum / count;
          // Re-threshold the blurred value
          dst[y * w + x] = avg > 127 ? 255 : 0;
        }
      }

      // Write back to the image data
      for (let i = 0; i < w * h; i++) {
        const v = dst[i];
        const idx = i * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = v;
        data[idx + 3] = 255;
      }
    }

    // Apply adjustable crop (circle or square cameo)
    function applyCrop(imgData, w, h) {
      if (state.cropShape === 'none') return;

      const data = imgData.data;
      const cx = w / 2;
      const cy = h / 2;
      const minDim = Math.min(w, h);
      const halfSize = (minDim * state.cropSize) / 2;
      const r2 = halfSize * halfSize;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = x - cx;
          const dy = y - cy;
          let keep = false;

          if (state.cropShape === 'circle') {
            const dist2 = dx * dx + dy * dy;
            keep = dist2 <= r2;
          } else if (state.cropShape === 'square') {
            keep = Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize;
          }

          if (!keep) {
            const idx = (y * w + x) * 4;
            data[idx] = 255;
            data[idx + 1] = 255;
            data[idx + 2] = 255;
            data[idx + 3] = 255;
          }
        }
      }
    }

    function processImage() {
      if (!imgLoaded) return;

      fitCanvasToImage();
      previewPlaceholder.style.display = 'none';

      const w = canvasW;
      const h = canvasH;

      ctxPreview.clearRect(0, 0, w, h);

      ctxPreview.save();
      if (state.flipHorizontal) {
        ctxPreview.translate(w, 0);
        ctxPreview.scale(-1, 1);
      }

      const filterParts = [];
      if (state.blur > 0) filterParts.push('blur(' + state.blur + 'px)');
      if (state.contrast !== 0) {
        const contrastPct = 100 + state.contrast;
        filterParts.push('contrast(' + contrastPct + '%)');
      }
      ctxPreview.filter = filterParts.join(' ') || 'none';

      ctxPreview.drawImage(img, 0, 0, w, h);
      ctxPreview.restore();
      ctxPreview.filter = 'none';

      let imgData = ctxPreview.getImageData(0, 0, w, h);
      let data = imgData.data;

      if (state.traceMode === 'shadow') {
        // 1) Grayscale + optional invert + initial threshold
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          let v = 0.299 * r + 0.587 * g + 0.114 * b;
          if (state.subjectLighter) {
            v = 255 - v;
          }
          const out = v < state.threshold ? 0 : 255;
          data[i] = data[i + 1] = data[i + 2] = out;
          data[i + 3] = 255;
        }

        // 2) Smooth the silhouette to “round off” hair weirdness
        smoothBinaryMask(imgData, w, h);

      } else if (state.traceMode === 'outline') {
        const gray = new Uint8ClampedArray(w * h);
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const idx = (y * w + x) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            let v = 0.299 * r + 0.587 * g + 0.114 * b;
            if (state.subjectLighter) {
              v = 255 - v;
            }
            gray[y * w + x] = v;
          }
        }

        const sobelOut = new Uint8ClampedArray(w * h);
        const gxKernel = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
        const gyKernel = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

        for (let y = 1; y < h - 1; y++) {
          for (let x = 1; x < w - 1; x++) {
            let gx = 0;
            let gy = 0;
            let k = 0;
            for (let ky = -1; ky <= 1; ky++) {
              for (let kx = -1; kx <= 1; kx++) {
                const px = gray[(y + ky) * w + (x + kx)];
                gx += gxKernel[k] * px;
                gy += gyKernel[k] * px;
                k++;
              }
            }
            const magnitude = Math.sqrt(gx * gx + gy * gy);
            sobelOut[y * w + x] = magnitude > 255 ? 255 : magnitude;
          }
        }

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const idx = (y * w + x) * 4;
            const m = sobelOut[y * w + x];
            const out = m > state.threshold ? 0 : 255;
            data[idx] = data[idx + 1] = data[idx + 2] = out;
            data[idx + 3] = 255;
          }
        }
      }

      // Projector hotspot
      if (state.hotspot) {
        const radiusInner = Math.min(w, h) * 0.15;
        const radiusOuter = Math.min(w, h) * 0.65;
        const grad = ctxPreview.createRadialGradient(
          w / 2, h / 2, radiusInner,
          w / 2, h / 2, radiusOuter
        );
        grad.addColorStop(0, 'rgba(255,255,255,0.16)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctxPreview.globalCompositeOperation = 'screen';
        ctxPreview.fillStyle = grad;
        ctxPreview.fillRect(0, 0, w, h);
        ctxPreview.globalCompositeOperation = 'source-over';

        // Re-read image data after hotspot
        imgData = ctxPreview.getImageData(0, 0, w, h);
        data = imgData.data;
      }

      // Apply crop (circle or square cameo)
      applyCrop(imgData, w, h);

      ctxPreview.putImageData(imgData, 0, 0);

      updateLabels();
      enableExportButtons(true);
    }

    function enableExportButtons(on) {
      downloadPngBtn.disabled = !on;
      downloadSvgBtn.disabled = !on;
    }

    function handleFileChange(e) {
      const file = e.target.files[0];
      if (!file) {
        imgLoaded = false;
        previewPlaceholder.style.display = 'block';
        ctxPreview.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        enableExportButtons(false);
        return;
      }
      const reader = new FileReader();
      reader.onload = function(evt) {
        img = new Image();
        img.onload = function() {
          imgLoaded = true;
          origThumb.src = img.src;
          previewPlaceholder.style.display = 'none';
          fitCanvasToImage();
          processImage();
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    }

    function downloadPNG() {
      if (!imgLoaded) return;
      const link = document.createElement('a');
      link.download = 'student_trace.png';
      link.href = previewCanvas.toDataURL('image/png');
      link.click();
    }

    function downloadSVG() {
      if (!imgLoaded) return;
      const w = canvasW;
      const h = canvasH;
      const pngDataUrl = previewCanvas.toDataURL('image/png');
      const svg =
        '<svg xmlns="http://www.w3.org/2000/svg" width="' + w +
        '" height="' + h + '" viewBox="0 0 ' + w + ' ' + h + '">' +
        '<image href="' + pngDataUrl + '" width="' + w + '" height="' + h + '"/></svg>';

      const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.download = 'student_trace.svg';
      link.href = url;
      link.click();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    }

    fileInput.addEventListener('change', handleFileChange);

    contrastSlider.addEventListener('input', () => {
      state.contrast = parseInt(contrastSlider.value, 10);
      updateLabels();
      processImage();
    });

    blurSlider.addEventListener('input', () => {
      state.blur = parseFloat(blurSlider.value);
      updateLabels();
      processImage();
    });

    thresholdSlider.addEventListener('input', () => {
      state.threshold = parseInt(thresholdSlider.value, 10);
      updateLabels();
      processImage();
    });

    subjectLighterCheckbox.addEventListener('change', () => {
      state.subjectLighter = subjectLighterCheckbox.checked;
      processImage();
    });

    flipHorizontalCheckbox.addEventListener('change', () => {
      state.flipHorizontal = flipHorizontalCheckbox.checked;
      processImage();
    });

    hotspotCheckbox.addEventListener('change', () => {
      state.hotspot = hotspotCheckbox.checked;
      processImage();
    });

    cropShapeSelect.addEventListener('change', () => {
      state.cropShape = cropShapeSelect.value;
      updateLabels();
      processImage();
    });

    cropSizeSlider.addEventListener('input', () => {
      state.cropSize = parseInt(cropSizeSlider.value, 10) / 100;
      updateLabels();
      processImage();
    });

    traceModeSelect.addEventListener('change', () => {
      state.traceMode = traceModeSelect.value;
      processImage();
    });

    resetImageAdjustBtn.addEventListener('click', () => {
      setDefaultsImageAdjust();
      processImage();
    });

    resetSensitivityBtn.addEventListener('click', () => {
      setDefaultsSensitivity();
      processImage();
    });

    resetAllBtn.addEventListener('click', () => {
      resetAll();
    });

    downloadPngBtn.addEventListener('click', downloadPNG);
    downloadSvgBtn.addEventListener('click', downloadSVG);

    // init
    setDefaultsImageAdjust();
    setDefaultsSensitivity();
    setDefaultsProjector();
    updateLabels();
    enableExportButtons(false);
  })();
</script>
</body>
</html>
