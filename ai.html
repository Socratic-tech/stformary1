<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trace Pro (Lightroom Style)</title>
    <style>
        :root {
            --bg-app: #1e1e1e;       /* Deepest background */
            --bg-panel: #262626;     /* Sidebar background */
            --bg-input: #121212;     /* Input fields */
            --border: #383838;       /* Separators */
            --accent: #2a8ceb;       /* Adobe Blue */
            --text-main: #e8e8e8;    /* Primary text */
            --text-sub: #9b9b9b;     /* Labels */
            --slider-track: #484848;
            --slider-thumb: #a0a0a0;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-app);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 12px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- TOP BAR --- */
        header {
            height: 32px;
            background-color: #323232;
            display: flex;
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid #111;
            justify-content: space-between;
        }
        .app-title { font-weight: 600; color: #ccc; letter-spacing: 0.5px; }
        .app-version { color: #666; margin-left: 5px; font-weight: 400; }
        .header-actions button {
            background: none; border: none; color: #aaa; padding: 4px 8px; cursor: pointer; font-size: 11px;
        }
        .header-actions button:hover { color: white; }

        /* --- MAIN LAYOUT --- */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* --- CENTER VIEWPORT --- */
        .viewport {
            flex: 1;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        
        /* The Canvas Wrapper keeps the image centered */
        .canvas-wrapper {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            line-height: 0;
        }
        canvas { display: block; max-width: 90vw; max-height: 90vh; }
        
        .empty-state {
            text-align: center;
            color: #444;
        }
        .upload-btn-big {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 15px;
        }
        .upload-btn-big:hover { background: #1a7acb; }

        /* --- RIGHT SIDEBAR --- */
        .sidebar {
            width: 300px;
            background-color: var(--bg-panel);
            border-left: 1px solid #111;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        /* Histogram Area */
        .histogram-container {
            height: 120px;
            padding: 10px;
            border-bottom: 1px solid var(--border);
            background: #202020;
            display: flex;
            flex-direction: column;
        }
        .hist-label { font-size: 10px; color: #666; margin-bottom: 4px; display:flex; justify-content: space-between; }
        #histCanvas { width: 100%; height: 100%; opacity: 0.8; }

        /* Accordion Panels */
        .panel { border-bottom: 1px solid var(--border); }
        
        .panel-header {
            padding: 8px 12px;
            background: #2a2a2a;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            font-size: 11px;
            color: #ddd;
        }
        .panel-header::before {
            content: '▼';
            font-size: 8px;
            margin-right: 8px;
            color: #888;
            transition: transform 0.2s;
        }
        .panel.closed .panel-header::before { transform: rotate(-90deg); }
        .panel.closed .panel-body { display: none; }

        .panel-body { padding: 12px; }

        /* Controls */
        .control-group { margin-bottom: 15px; }
        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            color: var(--text-sub);
        }
        .control-val { color: var(--text-main); font-variant-numeric: tabular-nums; }

        /* Pro Sliders */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            background: var(--slider-track);
            border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
            margin-top: -5px; /* Centers thumb */
            transition: background 0.1s;
        }
        input[type=range]:hover::-webkit-slider-thumb { background: #fff; }
        input[type=range]:active::-webkit-slider-thumb { background: var(--accent); }

        /* Toggles (Checkboxes looking like UI) */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 4px 0;
        }
        input[type="checkbox"] { accent-color: var(--accent); }

        /* Buttons */
        .btn-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        .btn {
            background: #3e3e3e;
            color: white;
            border: 1px solid #111;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
        }
        .btn:hover { background: #4e4e4e; }
        .btn.primary { background: #262626; border: 1px solid var(--accent); color: var(--accent); }
        .btn.primary:hover { background: var(--accent); color: white; }
        .btn:disabled { opacity: 0.3; cursor: default; }

        /* Bottom Status Bar */
        .status-bar {
            height: 24px;
            background: #323232;
            border-top: 1px solid #111;
            display: flex;
            align-items: center;
            padding: 0 10px;
            color: #666;
            font-size: 10px;
            justify-content: space-between;
        }

        #fileInput { display: none; }
    </style>
</head>
<body>

    <header>
        <div class="app-title">TRACE PRO <span class="app-version">LR</span></div>
        <div class="header-actions">
            <button onclick="document.getElementById('fileInput').click()">Import Photo...</button>
            <button onclick="resetAll()">Reset All</button>
        </div>
    </header>

    <div class="workspace">
        <div class="viewport">
            <div id="emptyState" class="empty-state">
                <div style="font-size: 40px; color: #333; margin-bottom: 10px;">⧉</div>
                <div>No Image Selected</div>
                <button class="upload-btn-big" onclick="document.getElementById('fileInput').click()">Open Photo</button>
                <p style="font-size: 10px; color: #555; margin-top: 10px;">Supports JPG, PNG</p>
            </div>
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
            </div>
        </div>

        <div class="sidebar">
            
            <div class="histogram-container">
                <div class="hist-label"><span>HISTOGRAM</span> <span>RGB</span></div>
                <canvas id="histCanvas"></canvas>
            </div>

            <div class="panel">
                <div class="panel-header" onclick="togglePanel(this)">Basic</div>
                <div class="panel-body">
                    <div class="control-group">
                        <div class="control-label">Contrast <span id="contrastVal" class="control-val">0</span></div>
                        <input type="range" id="contrast" min="0" max="200" value="0">
                    </div>
                    <div class="control-group">
                        <div class="control-label">Softness (Blur) <span id="blurVal" class="control-val">2.0</span></div>
                        <input type="range" id="blur" min="0" max="10" value="2.0" step="0.5">
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header" onclick="togglePanel(this)">Threshold</div>
                <div class="panel-body">
                    <div class="control-group">
                        <div class="control-label">Cutoff <span id="threshVal" class="control-val">128</span></div>
                        <input type="range" id="threshold" min="0" max="255" value="128">
                    </div>
                    
                    <div class="toggle-row">
                        <span>Mode: Outline Trace</span>
                        <input type="checkbox" id="traceModeToggle">
                    </div>

                    <div class="toggle-row">
                        <span>Invert (Light Subject)</span>
                        <input type="checkbox" id="invert">
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header" onclick="togglePanel(this)">Transform</div>
                <div class="panel-body">
                    <div class="toggle-row">
                        <span>Flip Horizontal</span>
                        <input type="checkbox" id="flip" checked>
                    </div>
                    <div class="toggle-row">
                        <span>Projector Hotspot</span>
                        <input type="checkbox" id="hotspot">
                    </div>
                    <div class="control-group" style="margin-top:10px;">
                        <div class="control-label">Crop (Zoom) <span id="cropVal" class="control-val">100%</span></div>
                        <input type="range" id="crop" min="50" max="100" value="100">
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header" onclick="togglePanel(this)">Export</div>
                <div class="panel-body">
                    <div class="btn-row">
                        <button id="dlPng" class="btn primary" disabled>Export PNG</button>
                        <button id="dlSvg" class="btn" disabled>Export SVG</button>
                    </div>
                    <div style="font-size: 10px; color: #666; margin-top: 10px; line-height: 1.4;">
                        Use PNG for projection. Use SVG for Cricut/Laser cutting.
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div class="status-bar">
        <span id="statusDims">Ready</span>
        <span>Zoom: Fit</span>
    </div>

    <input type="file" id="fileInput" accept="image/*">

    <script src="https://cdn.jsdelivr.net/gh/jankovicsandras/imagetracerjs@1.2.5/imagetracer_v1.2.5.js"></script>

    <script>
        // DOM Elements
        const fileInput = document.getElementById('fileInput');
        const emptyState = document.getElementById('emptyState');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const histCanvas = document.getElementById('histCanvas');
        const histCtx = histCanvas.getContext('2d');

        // Inputs
        const contrastIn = document.getElementById('contrast');
        const blurIn = document.getElementById('blur');
        const threshIn = document.getElementById('threshold');
        const flipIn = document.getElementById('flip');
        const invertIn = document.getElementById('invert');
        const hotspotIn = document.getElementById('hotspot');
        const cropIn = document.getElementById('crop');
        const traceModeIn = document.getElementById('traceModeToggle');
        
        // Buttons
        const dlPng = document.getElementById('dlPng');
        const dlSvg = document.getElementById('dlSvg');
        const statusDims = document.getElementById('statusDims');

        // State
        let currentImg = new Image();
        let isLoaded = false;

        // UI Helpers
        function togglePanel(header) {
            header.parentElement.classList.toggle('closed');
        }

        function updateLabels() {
            document.getElementById('contrastVal').innerText = (contrastIn.value > 0 ? '+' : '') + contrastIn.value;
            document.getElementById('blurVal').innerText = blurIn.value;
            document.getElementById('threshVal').innerText = threshIn.value;
            document.getElementById('cropVal').innerText = cropIn.value + '%';
        }

        // --- HISTOGRAM GENERATOR ---
        function drawHistogram(data) {
            // Setup frequency bins
            const bins = new Array(256).fill(0);
            for (let i = 0; i < data.length; i += 4) {
                // Approximate brightness
                const val = Math.round(0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]);
                bins[val]++;
            }
            
            // Normalize
            const max = Math.max(...bins);
            histCanvas.width = 280; 
            histCanvas.height = 100;
            histCtx.clearRect(0,0,280,100);
            
            histCtx.fillStyle = "#555";
            histCtx.beginPath();
            histCtx.moveTo(0, 100);
            
            for (let i=0; i<256; i++) {
                const h = (bins[i] / max) * 100;
                // Scale width to fit canvas
                const x = (i/255) * 280;
                histCtx.lineTo(x, 100 - h);
            }
            histCtx.lineTo(280, 100);
            histCtx.fill();

            // Draw Threshold Line
            const threshX = (parseInt(threshIn.value) / 255) * 280;
            histCtx.strokeStyle = "#2a8ceb";
            histCtx.lineWidth = 1;
            histCtx.beginPath();
            histCtx.moveTo(threshX, 0);
            histCtx.lineTo(threshX, 100);
            histCtx.stroke();
        }

        // --- MAIN PIPELINE ---
        function processImage() {
            if (!isLoaded) return;

            // 1. Calculations
            const w = currentImg.width;
            const h = currentImg.height;

            // Handle Crop (Zoom in center)
            const cropPct = parseInt(cropIn.value) / 100; // 0.5 to 1.0
            const cropW = w * cropPct;
            const cropH = h * cropPct;
            const cropX = (w - cropW) / 2;
            const cropY = (h - cropH) / 2;

            canvas.width = cropW;
            canvas.height = cropH;

            statusDims.innerText = `${cropW.toFixed(0)} x ${cropH.toFixed(0)} px`;

            // 2. Temp Canvas for Processing
            const tempCvs = document.createElement('canvas');
            tempCvs.width = cropW;
            tempCvs.height = cropH;
            const tCtx = tempCvs.getContext('2d');

            // Apply Flip & Draw
            tCtx.save();
            if (flipIn.checked) {
                tCtx.translate(cropW, 0); 
                tCtx.scale(-1, 1);
            }
            
            // Apply Filters (Contrast / Blur)
            const contrast = 100 + parseInt(contrastIn.value);
            const blur = parseFloat(blurIn.value);
            tCtx.filter = `contrast(${contrast}%) blur(${blur}px)`;
            
            // Draw Cropped Image
            tCtx.drawImage(currentImg, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);
            tCtx.restore();

            // 3. Thresholding
            const frame = tCtx.getImageData(0, 0, cropW, cropH);
            const data = frame.data;
            const thresh = parseInt(threshIn.value);
            const isInverted = invertIn.checked;

            // Update Histogram based on PRE-threshold data
            drawHistogram(data);

            for (let i = 0; i < data.length; i += 4) {
                const b = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
                let isSubject = isInverted ? (b > thresh) : (b < thresh);

                if (isSubject) {
                    data[i] = 0; data[i+1] = 0; data[i+2] = 0; data[i+3] = 255; // Black
                } else {
                    data[i+3] = 0; // Transparent
                }
            }
            tCtx.putImageData(frame, 0, 0);

            // 4. Final Render to Viewport Canvas
            ctx.clearRect(0, 0, cropW, cropH);

            // Background
            if (hotspotIn.checked) {
                const g = ctx.createRadialGradient(cropW/2, cropH/2, cropW/5, cropW/2, cropH/2, cropW);
                g.addColorStop(0, "#ffffff"); g.addColorStop(1, "#dcdcdc");
                ctx.fillStyle = g;
            } else {
                ctx.fillStyle = "#ffffff";
            }
            ctx.fillRect(0, 0, cropW, cropH);

            // Trace Mode vs Shadow Mode
            if (traceModeIn.checked) {
                drawOutline(tCtx, cropW, cropH);
            } else {
                ctx.drawImage(tempCvs, 0, 0);
            }
        }

        // Outline Helper
        function drawOutline(maskCtx, w, h) {
            const data = maskCtx.getImageData(0, 0, w, h).data;
            const outlineData = ctx.createImageData(w, h);
            const out = outlineData.data;

            for (let y = 1; y < h-1; y++) {
                for (let x = 1; x < w-1; x++) {
                    const i = (y * w + x) * 4;
                    if (data[i+3] === 0) { // If transparent
                        const top = ((y-1)*w+x)*4; const bot = ((y+1)*w+x)*4;
                        const left = (y*w+(x-1))*4; const right = (y*w+(x+1))*4;
                        // If neighbor is black
                        if (data[top+3]>0 || data[bot+3]>0 || data[left+3]>0 || data[right+3]>0) {
                            out[i]=80; out[i+1]=80; out[i+2]=80; out[i+3]=255;
                        }
                    }
                }
            }
            ctx.putImageData(outlineData, 0, 0);
        }

        // Import
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    currentImg = img;
                    isLoaded = true;
                    emptyState.style.display = 'none';
                    dlPng.disabled = false;
                    dlSvg.disabled = false;
                    processImage();
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(file);
        });

        // Listeners
        const controls = [contrastIn, blurIn, threshIn, flipIn, invertIn, hotspotIn, cropIn, traceModeIn];
        controls.forEach(el => el.addEventListener('input', () => {
            updateLabels();
            processImage();
        }));

        // Export
        dlPng.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'trace_export.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        dlSvg.addEventListener('click', () => {
            // Simplified SVG generation for the pro tool (Shadow mode only for robustness)
            // Re-run the threshold logic on a temp canvas to get clean black/white data
            const temp = document.createElement('canvas');
            temp.width = canvas.width; temp.height = canvas.height;
            const t = temp.getContext('2d');
            
            // Re-draw logic (simplified for brevity, assumes current canvas state is close enough or re-calculates)
            // Ideally we re-run the whole "Temp Canvas" logic from processImage here to ensure pure black/white
            // But ImageTracer works decently on the canvas output if the background is white and subject is black
            const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
            const options = { ltres: 1, qtres: 1, pathomit: 8, colorsampling: 0, numberofcolors: 2 };
            let svgStr = window.ImageTracer.imagedataToSVG(imageData, options);
            
            if (traceModeIn.checked) {
                 svgStr = svgStr.replace(/fill="rgb\(0,0,0\)"/g, 'fill="none" stroke="rgb(60,60,60)" stroke-width="2"');
            }

            const blob = new Blob([svgStr], { type: "image/svg+xml;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'trace_vector.svg';
            link.href = url;
            link.click();
        });

        function resetAll() {
            contrastIn.value = 0; blurIn.value = 2.0; threshIn.value = 128;
            flipIn.checked = true; hotspotIn.checked = false; cropIn.value = 100;
            updateLabels(); processImage();
        }

        // Init
        updateLabels();
    </script>
</body>
</html>
